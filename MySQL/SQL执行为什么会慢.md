## 1.SQL 语句本身的不合理设计

### 全表扫描或全索引扫描

未使用索引（或索引失效），导致查询需要扫描整张表（全表扫描）或扫描全部索引（全索引扫描），尤其在大表中，耗时显著增加。
<br>
例：WHERE 条件中的列无索引、条件不匹配索引规则（如 LIKE '%xxx' 左模糊匹配）。

### 不合理的关联查询（JOIN）

多表连接时未通过索引关联，或关联条件不明确，导致产生笛卡尔积（数据量呈指数级膨胀）；或连接的表数据量大且无索引，导致大量无效计算。

### 低效的子查询与聚合操作

嵌套多层子查询（尤其是相关子查询）可能导致重复执行，效率极低；GROUP BY/ORDER BY
等聚合、排序操作未基于索引完成，需全表扫描后再聚合 / 排序。

### 不必要的列与数据读取

使用 SELECT * 读取无关列，或读取大字段（如 TEXT/BLOB），增加 IO 成本和数据传输量。

## 2.索引设计与使用问题

### 缺少必要索引

查询条件（WHERE、JOIN ON、ORDER BY、GROUP BY 涉及的列）未创建索引，导致全表扫描。

### 索引失效

对索引列使用函数 / 表达式（如 WHERE SUBSTR(name,1,3)='abc'）；
隐式类型转换（如字符串索引列用数字比较：WHERE phone=13800138000）；
索引列参与运算（如 WHERE id+1=100）；
WHERE 子句中用 OR 连接非索引列与索引列（如 WHERE idx_col=1 OR no_idx_col=2）。

### 索引设计不合理

索引选择性低（如对性别、状态等值少的列建索引，索引过滤效果差）；
索引过多（维护成本高，优化器可能选错索引）；
联合索引顺序错误（未遵循 “最左前缀原则”，导致部分索引失效）。

### 优化器选错索引

统计信息过时或不准确，导致优化器错误估计扫描行数，选择低效索引（如放弃高选择性索引，改用全表扫描）。

## 3.表结构与数据量问题

### 数据量过大

表数据量达亿级以上，即使有索引，索引树深度增加，扫描的索引页变多，查询效率下降。

### 表结构设计不合理

列过多（宽表）或包含大字段（TEXT/BLOB），导致单条记录体积大，读取时 IO 成本高；
未做分表分库（水平/垂直拆分），单表压力过大。

### 数据分布不均

某值对应的记录占比极高（如90%以上），查询该值时，即使有索引，仍需扫描大量记录（类似全表扫描）。

## 4.数据库配置与资源问题

### 缓存配置不足

innodb_buffer_pool_size 过小，导致数据/索引频繁从磁盘读取（而非内存缓存），IO 耗时增加。

### 内存缓存参数不合理

join_buffer_size（连接缓存）、sort_buffer_size（排序缓存）等过小，导致连接/排序操作无法在内存完成，需使用临时文件，效率骤降。

### 硬件资源瓶颈

CPU 使用率过高（大量复杂计算）、磁盘IO繁忙（机械硬盘读写慢）、内存不足（频繁换页）等，导致查询无法高效执行。

## 5.锁与并发问题

### 锁等待

查询需等待行锁（InnoDB）或表锁（MyISAM）释放，导致执行时间被拉长（如写操作未提交，读操作等待锁）。

### 高并发竞争

大量查询同时执行，竞争 CPU、IO、内存等资源，单个查询的执行时间被 “稀释”（如 1000 个并发查询同时跑，单条耗时从 10ms 增至 1s）。

