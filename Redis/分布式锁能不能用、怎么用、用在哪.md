# 前言

Redis分布式锁是分布式系统中解决并发问题的常用方案，但存在一些潜在问题，需合理使用。以下从存在的问题、是否能用、适用场景三个方面详细说明。

## Redis分布式锁存在的问题

### 锁提前过期

问题：锁需要设置过期时间（TTL）防止客户端宕机后锁永久持有，但如果业务执行时间超过TTL，锁会提前自动释放，此时其他客户端可能获取到锁，导致多个客户端同时操作资源（例如：两个请求同时扣减库存，出现超卖）。
<br>
举例：客户端A获取锁（TTL=10s），但业务执行耗时15s，锁在10s后释放；客户端B在第10s后获取到锁，与A同时操作资源。
<br>
解决：通过“自动续期”机制（如Redisson的“看门狗”），客户端持有锁时，后台线程每隔一段时间（如TTL的1/3）检查锁是否仍被持有，若持有则延长TTL，避免锁提前释放。

### 原子性问题

问题：释放锁时需先判断“锁是否为当前客户端持有”，再执行删除操作。若用两条命令（如先GET判断，再DEL删除），中间可能被中断（如客户端宕机、网络延迟），导致误删其他客户端的锁。
<br>
例如：客户端A的锁已过期，客户端B获取到锁；A此时执行GET发现锁不是自己的（但未执行DEL），若此时B的锁也过期，客户端C获取到锁；A继续执行DEL，误删了C的锁。
<br>
解决：用Lua脚本保证“判断+删除”的原子性。

### 集群脑裂

问题：在Redis主从/哨兵架构中，锁的写入仅在主节点，主节点宕机后从节点升级为新主节点。若主节点宕机时，锁未同步到从节点，新主节点会允许其他客户端获取锁，导致“两个客户端同时持有锁”（原主节点的锁未同步，新主节点的锁被新客户端获取）。
<br>
举例：主节点M持有客户端A的锁，M宕机时锁未同步到从节点S；S升级为主节点，客户端B在S上获取到锁，此时A和B同时持有锁。
<br>
解决：
<br>
方案 1：使用Redlock算法（Redis官方推荐），通过多个独立Redis实例（如5个），客户端需获取超过半数实例的锁才算成功，即使部分实例宕机，仍能保证锁的唯一性（但实现复杂，性能损耗较高）。
<br>
方案 2：业务层面接受极低概率的不一致（主从切换概率低），结合Redisson等库的主从+哨兵机制，降低风险。

### 死锁问题

问题：前面提到锁过期使用看门狗机制实现自动续期，但是当业务执行完成后解锁，取消看门狗机制（cancelExpirationRenewal方法）失败时，会造成客户端的看门狗机制无限续期。
<br>
解决：日志监控，当cancelExpirationRenewal方法失败，会抛出错误日志，检测到错误日志触发人工告警。

```java
    @Override
    public RFuture<Void> unlockAsync(long threadId) {
        RFuture<Boolean> future = unlockInnerAsync(threadId);

        CompletionStage<Void> f = future.handle((opStatus, e) -> {
            cancelExpirationRenewal(threadId);

            if (e != null) {
                throw new CompletionException(e);
            }
            if (opStatus == null) {
                IllegalMonitorStateException cause = new IllegalMonitorStateException("attempt to unlock lock, not locked by current thread by node id: "
                        + id + " thread-id: " + threadId);
                throw new CompletionException(cause);
            }

            return null;
        });

        return new CompletableFutureWrapper<>(f);
    }
```

## Redis分布式锁“能不能用”？

能⽤，但需基于成熟方案解决上述问题。
<br>
原生Redis命令（如SET NX PX）直接实现分布式锁风险较高（易出现锁过期、误释放等问题），但通过成熟的开源库（如 Redisson）可规避这些问题：
<br>

    ·Redisson内置“看门狗”自动续期，解决锁过期问题；
    ·用Lua脚本保证释放锁的原子性；
    ·支持重入锁、公平锁等高级特性；
    ·对Redis集群（主从/哨兵/Cluster）有较好的适配。

<br>
因此，在实际开发中，不建议手写Redis分布式锁，而是直接使用Redisson等经过验证的库，即可安全使用。

## Redis分布式锁的适用场景

Redis 分布式锁的核心优势是高性能（Redis单节点QPS可达10万级），但存在极端情况下的一致性风险（如主从切换导致的短暂锁冲突）。因此，适用场景需满足：
<br>

    ·需要分布式环境下的并发控制：多节点/多服务实例需竞争同一资源（如库存、任务队列）。
    ·对性能要求高：并发量较大（如秒杀、高频接口），需低延迟的锁操作。
    ·能接受极低概率的一致性偏差：允许极端情况下（如Redis主从切换）出现短暂的并发冲突（概率极低，且可通过业务补偿、对账等措施解决）。

典型适用场景：

    ·电商库存扣减（流量不大）：防止超卖。多个服务实例同时处理下单请求，通过分布式锁保证同一商品库存同一时间仅被一个请求修改。
    ·分布式任务调度：避免同一任务被多个节点重复执行（如定时任务“清理过期订单”，需保证同一时间只有一个节点执行）。
    ·缓存并发更新：防止缓存击穿（热点key过期时，大量请求同时穿透到数据库），通过锁控制只有一个请求更新缓存，其他请求等待。
    ·分布式限流/熔断：在分布式系统中控制某一资源的并发访问量（如限制某接口每秒最多100次请求）。

不适用场景：

    ·对一致性要求极高，不允许任何并发冲突：例如金融交易的核心步骤（如转账、支付确认），极端情况下的锁冲突可能导致资金损失，
     此时更适合使用强一致性方案（如ZooKeeper分布式锁，基于临时节点和Watcher机制，一致性更高但性能较低）。
    ·低并发、低性能要求的场景：若并发量极低（如日均几千次请求），用数据库悲观锁（如SELECT...FORUPDATE）更简单，无需引入Redis。

