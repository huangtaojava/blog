Redis 提供了三种不同的机制来处理多个命令的执行：事务（MULTI/EXEC/DISCARD/WATCH）、Lua脚本和Pipeline，它们各自有不同的实现方式和适用场景。

## 1.Redis 事务 (MULTI/EXEC/DISCARD/WATCH)

##### 是什么：

    ○ 一组命令的批量执行，保证这些命令被顺序地、串行地、隔离地执行（不会被其他客户端的命令打断）。
    ○ 通过MULTI开始事务，EXEC执行事务队列中的所有命令，DISCARD取消事务，WATCH在事务开始前监视键以实现乐观锁。

##### 核心特点：

    ○ 原子性：部分保证：EXEC 命令执行时，队列中的所有命令要么全部被执行，要么全部不被执行。但这仅表示命令执行是原子的，
            不保证命令本身执行成功（例如 INCR 一个非数字类型的值会失败，但事务中其他命令依然执行）。它没有真正的回滚机制。
    ○ 隔离性：事务执行期间不会被其他客户端命令打断。
    ○ 非回滚：某个命令失败不会影响后续命令的执行，也不会回滚之前成功的命令。需要开发者自己处理错误。（非关系数据库中严格意义上的事务）
    ○ 乐观锁 (WATCH)：在 MULTI 之前 WATCH 一个或多个键。如果在EXEC前这些键被其他客户端修改，则EXEC 会失败，客户端需要重试整个逻辑。

##### 应用场景：

    ○ 需要将多个命令作为一个不可分割的单元执行（即使没有真正的回滚）。
    ○ 需要利用WATCH实现乐观锁控制的场景（如扣减库存、防止并发覆盖）。
    ○ 对命令执行顺序有严格要求，且不希望中间被其他命令插入。

## 2.Lua脚本

##### 是什么：

    ○ 在Redis服务器端原子性执行的一段Lua脚本代码。
    ○ 使用EVAL或EVALSHA命令执行。

##### 核心特点：

    ○ 原子性：Lua脚本在执行时独占整个Redis服务器，可以保证并发编程中不可拆分、不被中断的这个原子性，
             但是没有保证数据库ACID中要么都执行要么都回滚的这个原子性。
             这是Redis提供的最强原子性保证（机器断电、宕机无法保证原子性）。
    ○ 高性能：脚本在服务端执行，避免了多次网络往返开销（类似Pipeline的效果）。
    ○ 灵活性：Lua 语言提供了分支、循环、变量、函数等强大的逻辑控制能力，可以封装复杂逻辑。
    ○ 复用性：脚本可以被缓存 (SCRIPT LOAD + EVALSHA) 以提高效率。
    ○ 服务端计算：可以在服务端执行计算逻辑，减少传输到客户端的数据量。

##### 应用场景：

    ○ 需要严格原子性的复杂操作（如CAS操作、涉及多个键的复杂判断和更新）。
    ○ 实现复杂逻辑（如限流器、分布式锁的释放逻辑、排行榜更新逻辑）。
    ○ 需要减少网络开销且操作逻辑相对固定的场景。
    ○ 需要在服务端进行数据过滤、聚合或计算再返回结果的场景。

## 3.Pipeline

##### 是什么：

    ○ 一种客户端技术。客户端将多个命令一次性打包发送给Redis服务器，服务器按顺序处理完所有命令后，再将所有结果一次性打包返回给客户端。
    ○ 不是Redis的协议命令，而是客户端库（如Jedis,StackExchange.Redis,redis-py）提供的功能。

##### 核心特点：

    ○ 大幅减少网络延迟：这是Pipeline最主要的目的。它将N次网络往返时间(RTT)压缩到1次（发送）+ 1次（接收）。
    ○ 提升吞吐量：单位时间内可以处理更多的命令。
    ○ 无原子性保证：Pipeline中的命令在服务器端是逐个执行的，在执行过程中，其他客户端的命令可能穿插执行在这些命令之间，服务器只是把命令打包接收和打包返回结果。
    ○ 无事务性：不提供隔离性、回滚等事务特性。

##### 应用场景：

    ○ 性能优化：需要批量执行大量独立命令且不要求原子性的场景。这是Pipeline最核心的价值。
    ○ 初始化缓存、批量导入/导出数据。
    ○ 执行大量GET、SET、HSET等不互相依赖的操作。