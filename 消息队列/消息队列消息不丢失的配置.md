## RocketMQ

### 发送端

使用同步发送或者带回调的异步发送，直到发送结果明确告知发送成功

```java
DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP);
producer.

setNamesrvAddr(DEFAULT_NAMESRVADDR);
//发送失败重试次数
producer.

setRetryTimesWhenSendFailed(3);
producer.

setRetryAnotherBrokerWhenNotStoreOK(true);
producer.

start();

Message msg = new Message(TOPIC, TAG, ("Hello RocketMQ ").getBytes(RemotingHelper.DEFAULT_CHARSET));
SendResult sendResult = producer.send(msg);
if(!sendResult.

getSendStatus().

equals(SendStatus.SEND_OK)){
        //不成功，重试，直到成功为止
        }
```

### Broker端配置

主从同步复制 + 同步刷盘

```lombok.config
brokerRole = SYNC_MASTER  # 主节点同步复制（保证主从数据一致）
flushDiskType = SYNC_FLUSH # 同步刷盘（写入磁盘才返回ACK）
```

### 消费者端

```java
consumer.registerMessageListener((MessageListenerConcurrently) (msgs,context)->{
        try{
        // 业务处理
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 成功才提交
    }catch(
Exception e){
        return ConsumeConcurrentlyStatus.RECONSUME_LATER; // 失败重试
    }
            });
```

## Kafka

### 发送端

```java
Properties props = new Properties();
props.

put("bootstrap.servers","kafka-server:9092");
//必须等待所有 ISR（In-Sync Replicas）副本写入成功后才返回确认，避免 Leader 副本宕机导致消息丢失
props.

put("acks","all");
//发送失败无限重试
props.

put("retries",Integer.MAX_VALUE);

Producer<String, String> producer = new KafkaProducer<>(props);
//使用异步带回调的发送方式
producer.

send(new ProducerRecord<>(topic, key, value), new

ProducerCallback(key, value));
```

### Broker端配置

    ● 设置replication.factor >= 3。将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。
    ● 设置min.insync.replicas > 1。控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于1可以提升消息持久性。
      在实际环境中千万不要使用默认值1。
    ● 设置unclean.leader.election.enable = false。它控制的是哪些Broker有资格竞选分区的Leader。
      如果一个Broker落后原先的Leader太多，那么它一旦成为新的Leader，必然会造成消息的丢失。故一般都要将该参数设置成false，即不允许这种情况的发生。
    ● 确保replication.factor > min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。
      我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成replication.factor = min.insync.replicas + 1。

```lombok.config
replication.factor=3
min.insync.replicas=2
unclean.leader.election.enable=false
log.flush.interval.messages=10000
log.flush.interval.ms=1000
```

### 消费者端

```java
Properties props = new Properties();
props.

put("bootstrap.servers","kafka-server:9092");
props.

put("group.id","my-group");
//使用手动提交位移
props.

put("enable.auto.commit","false");

Consumer<String, String> consumer = new KafkaConsumer<>(props);
while(true){
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
    for(
ConsumerRecord<String, String> record :records){

processRecord(record); // 业务处理
        consumer.

commitSync(); // 同步提交 Offset
    }
            }
```

### 由于kafka不支持同步刷盘策略，在极端情况下，如所有节点机器掉电，还是会丢失消息的，它的数据一致性低于RocketMQ